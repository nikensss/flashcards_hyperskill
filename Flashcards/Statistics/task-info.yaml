type: edu
custom_name: stage6
files:
- name: test/common/DialogClue.kt
  visible: false
  text: |
    package common

    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testcase.TestCase


    // ---- DialogClue ----

    /** May be several lines or just one. */
    interface Phrase {
        fun toPhraseLines(): List<PhraseLine>
    }

    /** list of input and output lines, combined together. */
    fun compositePhrase(block: () -> List<Phrase>) = object : Phrase {
        override fun toPhraseLines() = block().flatMap { it.toPhraseLines() }
    }

    fun compositePhrase(vararg phrases: Phrase) = object : Phrase {
        override fun toPhraseLines() = phrases.flatMap { it.toPhraseLines() }
    }

    /** Either user (input) or output phrase. Each phrase should be a line. */
    sealed class PhraseLine : Phrase {
        override fun toPhraseLines() = listOf(this)
    }

    /** Some mutable data, that is passed across dialog phrases. */
    class Context {
        val rawData = mutableMapOf<String, Any>()
    }

    class UserLine(val text: String, val updateContext: CtxUpdate = {}) : PhraseLine() {

    }
    typealias CtxUpdate = (ctx: Context) -> Unit

    class OutputLine(val checker: (text: String, ctx: Context) -> CheckResult) : PhraseLine()

    /** This function creates a line with user input (our test input).
     *
     * Unfortunately we can't access the Context, when we adding user text.
     * This occurs because of HS test framework limitations:
     * we need to pass all inputs first, and then start checking outputs. */
    fun user(text: String, updateContext: (ctx: Context) -> Unit = {}) = UserLine(text, updateContext)

    fun anyLine(updateContext: CtxUpdate = {}) = OutputLine { _, ctx -> CheckResult.correct().also { updateContext(ctx) } }

    fun containing(
            vararg parts: String,
            ignoreCase: Boolean = true,
            hint: String? = null,
            updateContext: CtxUpdate = {}
    ) = OutputLine { line, context ->
        fun buildFeedback(): String {
            val feedback = StringBuilder()
            feedback.append("Your line\n`$line`\nshould contain ${parts.joinToString("`, `", "`", "`")}")
            if (ignoreCase) {
                feedback.append(" (ignoring case)")
            }
            feedback.append(".")
            if (hint != null) {
                feedback.append("\n$hint")
            }
            return feedback.toString()
        }

        var startIndex = 0
        for (part in parts) {
            startIndex = line.indexOf(part, startIndex, ignoreCase)
            if (startIndex == -1) {
                return@OutputLine CheckResult.wrong(buildFeedback())
            }
        }
        updateContext(context) // everything is correct, update context
        CheckResult.correct();
    }

    class DialogClue(private val phrases: List<PhraseLine>) {

        private val inputPhrases = phrases.filter { it is UserLine }.map { it as UserLine }
        private val outputPhrases = phrases.filter { it is OutputLine }.map { it as OutputLine }

        fun generateInput() = inputPhrases
                .joinToString("\n", postfix = "\n") { it.text }

        fun checkOutput(output: String): CheckResult {
            val lines = output.lines()
                    .filter { it.isNotBlank() }

            fun wrongOutputSizeFeedback() = CheckResult.wrong("The number of lines in your output is ${lines.size}, " +
                    "but it should be ${outputPhrases.size}. " +
                    "Check, that you output your lines with println, not print. And there are no extra outputs.")

    // here we store some mutable data from phrase to phrase
            val context = Context()

            val lineIter = lines.listIterator()
            phrases.forEach { phraseLine ->
                when (phraseLine) {
                    is UserLine -> phraseLine.updateContext(context)
                    is OutputLine -> {
                        if (!lineIter.hasNext()) {
                            return wrongOutputSizeFeedback()
                        }
                        val result = phraseLine.checker(lineIter.next(), context)
                        if (!result.isCorrect) {
                            return CheckResult.wrong(result.feedback)
                        }
                    }
                }
            }

            if (lineIter.hasNext()) {
                return wrongOutputSizeFeedback()
            }

            return CheckResult.correct();
        }
    }

    fun dialogTest(vararg phrases: Phrase): TestCase<DialogClue> {
        val dialogClue = DialogClue(phrases.flatMap { it.toPhraseLines() })
        return TestCase<DialogClue>()
                .setInput(dialogClue.generateInput())
                .setAttach(dialogClue)
    }
  learner_created: false
- name: test/common/FlashcardsStage6Test.kt
  visible: false
  text: |
    package common

    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult
    import org.hyperskill.hstest.testcase.TestCase
    import flashcards.Main
    import java.io.File

    abstract class FlashcardsStage6Test : StageTest<DialogClue>(Main::class.java) {

        override fun generate(): List<TestCase<DialogClue>> {
            File("capitals.txt").delete()
            File("testLog.txt").delete()
            val tests = mutableListOf<TestCase<DialogClue>>()

            val capitalList = mutableListOf<Pair<String, String>>()
            fun capitals() = capitalList.toTypedArray()

            // wrappers for add/remove card, but saving cards to capitalList:
            fun addCapital(card: String, def: String) = addCard(card, def)
                    .also { capitalList += card to def }

            fun removeCapital(card: String) = removeCard(card)
                    .also { capitalList.removeIf { it.first == card } }

            // clear files
            tests += dialogTest(
                    exportCards("capitals.txt", 0),
                    exit()
            )
            tests += dialogTest(
                    hardestCards(),
                    addCapital("France", "Paris"),
                    askCards("France", "??"),
                    hardestCards(),// wrong cards for test are updated in the previous line
                    resetStats(),
                    hardestCards(),
                    addCapital("Russia", "Moscow"),
                    askCards("??", "??"),
                    hardestCards(),
                    askCards("??", "??"),
                    hardestCards(),
                    askCards("??", "??"),
                    hardestCards(),
                    askCards("??", "??"),
                    hardestCards(),
                    askCards("??", "??", saveWrongAnsweredCapitals = true),
                    hardestCards(),
                    exportCards("capitals.txt", 2),
                    log("testLog.txt"),
                    exit()
            )
            tests += dialogTest(
                    hardestCards(),
                    addCard("France", "UpdateMeFromImport"),
                    askCards("??", "??"),
                    importCards("capitals.txt", *capitals()),
                    hardestCards(wrongAnsweredCapitals), // restored from the previous test
                    removeCapital("France"),
                    removeCapital("Russia"),
                    hardestCards(), // empty
                    exit()
            )
            return tests
        }

        override fun check(reply: String, clue: DialogClue): CheckResult {
            return clue.checkOutput(reply)
        }


        // ------ extensions for building a dialog: ------

        fun inputAction(action: String) = compositePhrase {
            listOf(containing("action", hint = "This line should ask the action."), user(action))
        }

        inner class LogPhrase(val fileName: String) : Phrase {
            override fun toPhraseLines() = compositePhrase(
                    inputAction("log"),
                    OutputLine { text, ctx ->
                        val result = containing("File name:", hint = "This line should ask for a file name where the log should be saved.").checker(text, ctx)
                        if (!result.isCorrect) {
                            return@OutputLine result
                        }
                        CheckResult.correct();
                    },
                    user(fileName),
                    OutputLine { text, ctx ->
                        val result = containing("saved", hint = "This line should indicate, that the log has been saved.").checker(text, ctx)
                        if (!result.isCorrect) {
                            return@OutputLine result
                        }
                        if (!File(fileName).exists()) {
                            return@OutputLine CheckResult.wrong("The log file $fileName does not exist.")
                        }
                        CheckResult.correct();
                    }
            ).toPhraseLines()
        }

        private fun log(fileName: String) = LogPhrase(fileName)

        private fun resetStats() = compositePhrase(
                inputAction("reset stats"), containing("reset", hint = "This line should confirm card statistics reset.",
                updateContext = { ctx -> ctx.wrongCards.clear() })
        )

        /** Between tests we cache wrong answered capitals to check hardest cards, when we restore them from file. */
        private val wrongAnsweredCapitals: MutableList<String> = mutableListOf()

        /** [customWrongCards] are used to load saved wrong cards from the previous test. */
        fun hardestCards(customWrongCards: List<String>? = null) = compositePhrase(
                inputAction("hardest card"),
                OutputLine { text, ctx ->
                    if (customWrongCards != null) {
                        ctx.wrongCards.clear()
                        ctx.wrongCards.addAll(customWrongCards)
                    }
                    val groupedCards = ctx.wrongCards
                            .groupBy { it }.mapValues { (_, v) -> v.size }
                    val maxMistakes = groupedCards.values.max() ?: 0
                    val hardestCards = groupedCards.filterValues { it == maxMistakes }.keys.toList()

                    when (hardestCards.size) {
                        0 -> return@OutputLine containing("There are no cards with errors").checker(text, ctx)
                        1 -> return@OutputLine containing("The hardest card is \"${hardestCards[0]}\"",
                                "$maxMistakes").checker(text, ctx)
                        else -> {
                            hardestCards.forEach { card ->
                                if (card !in text) {
                                    return@OutputLine CheckResult.wrong("Your line `$text`\n" +
                                            "should contain the hardest cards " +
                                            "${hardestCards.joinToString("\", \"", "\"", "\"")} with $maxMistakes mistakes.")
                                }
                            }
                            val numberOfHardestCards = text.count { it == '"' }
                            if (numberOfHardestCards != hardestCards.size * 2) {
                                return@OutputLine CheckResult.wrong("Your line `$text`\n" +
                                        "contains more hardest cards, than expected. Expected: $hardestCards.")
                            }
                            if (maxMistakes.toString() !in text) {
                                if (numberOfHardestCards != hardestCards.size) {
                                    return@OutputLine CheckResult.wrong("Your line `$text`\n" +
                                            "should contain $maxMistakes mistakes for your hardest cards.")
                                }
                            }
                        }
                    }
                    CheckResult.correct();
                }
        )


        // extend dialog context with our own data:

        @Suppress("UNCHECKED_CAST")
        private val Context.cardToDef
            get() = rawData.getOrPut("cardToDef") { mutableMapOf<String, String>() } as MutableMap<String, String>

        @Suppress("UNCHECKED_CAST")
        /** All cards, that were answered wrong. */
        private val Context.wrongCards
            get() = rawData.getOrPut("wrongCards") { mutableListOf<String>() } as MutableList<String>


        @Suppress("UNCHECKED_CAST")
        private val Context.defToCard
            get() = rawData.getOrPut("defToCard") { mutableMapOf<String, String>() } as MutableMap<String, String>

        private fun Context.addCard(card: String, definition: String) {
            cardToDef[card] = definition
            defToCard[definition] = card
        }

        private fun Context.removeCard(card: String) {
            val def = cardToDef.remove(card)
            if (def != null) {
                defToCard.remove(def)
            }
        }


        private fun addCard(card: String, def: String) = compositePhrase(
                inputAction("add"),
                anyLine(), user(card),
                anyLine(), user(def),
                containing("has been added",
                        hint = "This line should add the pair (\"$card\":\"$def\").",
                        updateContext = { ctx -> ctx.addCard(card, def) })
        )


        private fun existingDef(card: String, def: String) = compositePhrase(
                inputAction("add"),
                anyLine(), user(card),
                anyLine(), user(def),
                containing("definition", "exists", hint = "This line should reject the existing definition `$def`.")
        )


        private fun existingCard(card: String) = compositePhrase(
                inputAction("add"),
                anyLine(), user(card),
                containing("card", "exists", hint = "This line should reject the existing card `$card`.")
        )

        private fun removeCard(card: String) = compositePhrase(
                inputAction("remove"),
                anyLine(), user(card),
                containing("has been removed", hint = "This line should remove the card `$card`.",
                        updateContext = { ctx ->
                            ctx.removeCard(card)
                            ctx.wrongCards.removeAll(listOf(card))
                        })
        )

        private fun removeNonExisting(card: String) = compositePhrase(
                inputAction("remove"),
                anyLine(), user(card),
                containing("Can't remove \"$card\"", hint = "This line should reject removing non existing card `$card`.")
        )


        private fun importCards(fileName: String, vararg cards: Pair<String, String>) = compositePhrase(
                inputAction("import"),
                anyLine(), user(fileName),
                containing("${cards.size} cards have been loaded",
                        updateContext = { ctx ->
                            val cardToDef = ctx.cardToDef
                            val defToCard = ctx.defToCard
                            cards.forEach { (card, def) ->
                                if (card in cardToDef) {
                                    defToCard.remove(cardToDef[card]) // erase wrong reverse link
                                }
                                ctx.addCard(card, def) // with update!!
                            }
                        })
        )

        private fun importNonExisting(fileName: String) = compositePhrase(
                inputAction("import"),
                anyLine(), user(fileName),
                containing("not found", hint = "This line should say, that the file $fileName does not exist.")
        )

        private fun exportCards(fileName: String, cardsSize: Int) = compositePhrase(
                inputAction("export"),
                anyLine(), user(fileName),
                containing("$cardsSize cards have been saved")
        )

        private fun exit() = compositePhrase(
                inputAction("exit"),
                anyLine()
        )

        /** Perform ask action. [ansDefs] are our test answers with definitions.
         * We don't know are they wrong or correct, because the test is random. */
        private fun askCards(vararg ansDefs: String, saveWrongAnsweredCapitals: Boolean = false) = compositePhrase {
            val startPhrases = listOf(
                    inputAction("ask"),
                    anyLine(), user(ansDefs.size.toString())
            )
            // here we add the dialog logic, by creating base OutputLine class with a custom checker
            // we use context to connect with neighbor checkers

            // iterate test answered definitions:
            val repeatingPhrases = ansDefs.map { ansDef ->
                compositePhrase(
                        OutputLine { text, ctx ->
                            val askedCard = text.dropWhile { it != '"' }.dropLastWhile { it != '"' }.trim('"')
                            if (askedCard.isEmpty()) {
                                return@OutputLine CheckResult.wrong("Not found card in quotes. " +
                                        "This line should ask the definition of a random card.")
                            }
                            if (askedCard !in ctx.cardToDef) {
                                return@OutputLine CheckResult.wrong("You asked the definition of the non existing card: `$askedCard`.")
                            }
                            ctx.rawData["lastAskedCard"] = askedCard
                            CheckResult.correct();
                        },
                        // unfortunately we can't access the Context in user action, see documentation of user()
                        user(ansDef),
                        // check the answer:
                        OutputLine { text, ctx ->
                            val askedCard = ctx.rawData["lastAskedCard"]?.toString()
                                    ?: throw IllegalStateException("Not found lastAskedCard in the `ask` checker.")
                            val cardToDef = ctx.cardToDef
                            val defToCard = ctx.defToCard
                            val rightAns = cardToDef[askedCard]

                            val hint = "The asked card was `$askedCard`, the answer was `$ansDef`."
                            if (cardToDef[askedCard] == ansDef)
                                containing("Correct", hint = hint).checker(text, ctx)
                            else {
                                ctx.wrongCards += askedCard

                                val isDefFor = defToCard[ansDef]
                                if (isDefFor != null) {
                                    containing("Wrong", "The right answer is \"$rightAns\"",
                                            "but your definition is correct for \"$isDefFor\"", hint = hint).checker(text, ctx)
                                } else {
                                    // should not contain definition hint!!
                                    if (text.contains("but your definition is correct for")) {
                                        CheckResult.wrong("Your line\n`$text`\nshould NOT contain " +
                                                "`but your definition is correct for`.\n$hint")
                                    } else {
                                        containing("Wrong", "The right answer is \"$rightAns\"", hint = hint).checker(text, ctx)
                                    }

                                }
                            }.also {
                                // only for these tests. To test restoring wrong capitals from file.
                                if (saveWrongAnsweredCapitals) {
                                    wrongAnsweredCapitals.clear()
                                    wrongAnsweredCapitals.addAll(ctx.wrongCards)
                                }
                            }
                        }
                )
            }
            (startPhrases + repeatingPhrases)
        }
    }
  learner_created: false
- name: test/FlashcardsTest.java
  visible: false
  text: "import flashcards.Main;\nimport org.hyperskill.hstest.dynamic.input.DynamicTestingMethod;\n\
    import org.hyperskill.hstest.stage.StageTest;\nimport org.hyperskill.hstest.testcase.CheckResult;\n\
    import org.hyperskill.hstest.testcase.TestCase;\nimport org.hyperskill.hstest.testing.TestedProgram;\n\
    import org.junit.AfterClass;\nimport org.junit.BeforeClass;\n\nimport java.io.BufferedReader;\n\
    import java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\
    import java.util.Arrays;\nimport java.util.List;\n\npublic class FlashcardsTest\
    \ extends StageTest<String> {\n    \n    private static List<String> listOfTerms;\n\
    \    private static List<String> listOfDefinitions;\n    private static List<String>\
    \ listOfAddedDefinitions;\n    private static List<String> listOfCountries;\n\
    \    private static List<String> listOfCapitals;\n    private final String capitalsFile\
    \ = \"capitals.txt\";\n    private final String capitalsNewFile = \"capitalsNew.txt\"\
    ;\n    \n    \n    @BeforeClass\n    public static void generateLists(){\n   \
    \     listOfTerms = getListOfTerms();\n        listOfDefinitions = getListOfDefinitions();\n\
    \        listOfAddedDefinitions = getListOfWrongDefinitions1();\n        listOfCountries\
    \ = getListOfCountries();\n        listOfCapitals = getListOfCapitals();\n   \
    \ }\n    \n    @AfterClass\n    public static void deleteFiles() {\n        File\
    \ capitalsFile = new File(\"capitals.txt\");\n        //noinspection ResultOfMethodCallIgnored\n\
    \        capitalsFile.delete();\n        \n        File capitalsNewFile = new\
    \ File(\"capitalsNew.txt\");\n        //noinspection ResultOfMethodCallIgnored\n\
    \        capitalsNewFile.delete();\n        \n        File logFile = new File(\"\
    todayLog.txt\");\n        //noinspection ResultOfMethodCallIgnored\n        logFile.delete();\n\
    \        \n    }\n    \n    @DynamicTestingMethod\n    CheckResult test1() {\n\
    \        TestedProgram main = new TestedProgram(Main.class);\n        \n     \
    \   String output = main.start().toLowerCase().trim();\n        if (!output.contains(\"\
    input the action\")) {\n            return CheckResult.wrong(\"Your program should\
    \ prompt the user for an action with the message \\\"Input the \" +\n        \
    \            \"action\\\"\");\n        }\n    \n        output = main.execute(\"\
    exit\").toLowerCase();\n        if (!output.contains(\"bye\")) {\n           \
    \ return CheckResult.wrong(\"Your program should print \\\"Bye bye!\\\" and terminate\
    \ if the user enters \" +\n                    \"\\\"exit\\\"\");\n        }\n\
    \    \n        if (!main.isFinished()) {\n            return CheckResult.wrong(\"\
    Your program should terminate if the user enters \\\"exit\\\"\");\n        }\n\
    \        \n        return CheckResult.correct();\n    }\n    \n    //Test to check\
    \ the \"add\" action\n    @DynamicTestingMethod\n    CheckResult test2() {\n \
    \       TestedProgram main = new TestedProgram(Main.class);\n        main.start();\n\
    \        \n        String output;\n        String lastLine;\n        String[]\
    \ lines;\n        \n        output = main.execute(\"add\").toLowerCase();\n  \
    \      if (!output.contains(\"card\")) {\n            return CheckResult.wrong(\"\
    Your program should prompt the user for the name of the card with the message\
    \  \" +\n                    \"\\\"The card:\\\"\");\n        }\n        \n  \
    \      output = main.execute(\"France\").toLowerCase();\n        if (!output.contains(\"\
    definition of the card\")) {\n            return CheckResult.wrong(\"Your program\
    \ should prompt the user for the definition of the card with the \" +\n      \
    \              \"message \\\"The definition of the card:\\\"\");\n        }\n\
    \        \n        output = main.execute(\"Paris\").toLowerCase();\n        if\
    \ (!output.contains(\"pair (\\\"france\\\":\\\"paris\\\") has been added\")) {\n\
    \            return CheckResult.wrong(\"Your program should print the message\
    \ \\\"The pair (\\\"term\\\":\\\"definition\\\") has \" +\n                  \
    \  \"been added\\\" after adding a card successfully\");\n        }\n        \n\
    \        lines = output.split(\"\\n\");\n        lastLine = lines[lines.length\
    \ - 1];\n        if (!lastLine.toLowerCase().contains(\"input the action\")) {\n\
    \            return CheckResult.wrong(\"Your program should continue to request\
    \ an action from the user until they \" +\n                    \"enter \\\"exit\\\
    \"\");\n        }\n        \n        main.execute(\"add\");\n        output =\
    \ main.execute(\"France\").toLowerCase();\n        if (!output.contains(\"card\
    \ \\\"france\\\" already exists\")) {\n            return CheckResult.wrong(\"\
    Your program should not add a card that already exists and should notify the \"\
    \ +\n                    \"user with the message \\\"The card 'term' already exists\\\
    \".\");\n        }\n        \n        lines = output.split(\"\\n\");\n       \
    \ lastLine = lines[lines.length - 1];\n        if (!lastLine.toLowerCase().contains(\"\
    input the action\")) {\n            return CheckResult.wrong(\"Your program should\
    \ request an action from the user if a card was declined \" +\n              \
    \      \"because it already exists\");\n        }\n        \n        main.execute(\"\
    add\");\n        main.execute(\"Great Britain\");\n        output = main.execute(\"\
    Paris\").toLowerCase();\n        if (!output.contains(\"definition \\\"paris\\\
    \" already exists\")) {\n            return CheckResult.wrong(\"Your program should\
    \ not add a definition that already exists and should notify \" +\n          \
    \          \"the \\\"user with the message \\\"The definition 'definition' already\
    \ exists\\\".\");\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should terminate if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check the \"remove\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test3() {\n        TestedProgram main = new TestedProgram(Main.class);\n\
    \        main.start();\n        \n        String output;\n        String lastLine;\n\
    \        String[] lines;\n        \n        //No need to check user's output because\
    \ they have been checked in test 2.\n        main.execute(\"add\");\n        main.execute(\"\
    France\");\n        main.execute(\"Paris\");\n        \n        main.execute(\"\
    add\");\n        main.execute(\"Japan\");\n        main.execute(\"Tokyo\");\n\
    \        \n        main.execute(\"add\");\n        main.execute(\"Great Britain\"\
    );\n        main.execute(\"London\");\n        \n        output = main.execute(\"\
    remove\").toLowerCase();\n        if (!output.contains(\"which card\")) {\n  \
    \          return CheckResult.wrong(\"Your program should prompt the user for\
    \ the name of the card with the message \" +\n                    \"\\\"Which\
    \ card?\\\"\");\n        }\n        \n        output = main.execute(\"Japan\"\
    ).toLowerCase();\n        if (!output.contains(\"card has been removed\")) {\n\
    \            return CheckResult.wrong(\"Your program should notify the user with\
    \ the message \" +\n                    \"\\\"The card has been removed.\\\" if\
    \ the card was removed successfully\");\n        }\n        \n        lines =\
    \ output.split(\"\\n\");\n        lastLine = lines[lines.length - 1];\n      \
    \  if (!lastLine.toLowerCase().contains(\"input the action\")) {\n           \
    \ return CheckResult.wrong(\"Your program should continue to request an action\
    \ from the user until they \" +\n                    \"enter \\\"exit\\\"\");\n\
    \        }\n        \n        main.execute(\"remove\");\n        output = main.execute(\"\
    Wakanda\").toLowerCase();\n        if (!output.contains(\"can't remove \\\"wakanda\\\
    \"\")) {\n            return CheckResult.wrong(\"Your program should notify the\
    \ user with the message\" +\n                    \" \\\"Can't remove 'card': there\
    \ is no such card.\\\" if the card doesn't exist\");\n        }\n        \n  \
    \      if (!output.contains(\"no such card\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user with the message\" +\n                   \
    \ \" \\\"Can't remove 'card': there is no such card.\\\" if the card doesn't exist\"\
    );\n        }\n        \n        lines = output.split(\"\\n\");\n        lastLine\
    \ = lines[lines.length - 1];\n        if (!lastLine.toLowerCase().contains(\"\
    input the action\")) {\n            return CheckResult.wrong(\"Your program should\
    \ request an action from the user even if a card could not be\" +\n          \
    \          \" removed\");\n        }\n        \n        main.execute(\"remove\"\
    );\n        output = main.execute(\"Tokyo\").toLowerCase();\n        if (output.contains(\"\
    card has been removed\")) {\n            return CheckResult.wrong(\"You should\
    \ not be able to remove a card by it's definition\");\n        }\n    \n     \
    \   output = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"\
    bye\")) {\n            return CheckResult.wrong(\"Your program should print \\\
    \"Bye bye!\\\" and terminate if the user enters \" +\n                    \"\\\
    \"exit\\\"\");\n        }\n    \n        if (!main.isFinished()) {\n         \
    \   return CheckResult.wrong(\"Your program should terminate if the user enters\
    \ \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check \"export\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test4() {\n        TestedProgram main = new TestedProgram(Main.class);\n\
    \        main.start();\n        \n        String output;\n        String lastLine;\n\
    \        String[] lines;\n        boolean fileExists;\n        boolean empty;\n\
    \        \n        main.execute(\"add\");\n        main.execute(\"Japan\");\n\
    \        main.execute(\"Tokyo\");\n        \n        main.execute(\"add\");\n\
    \        main.execute(\"France\");\n        main.execute(\"Paris\");\n       \
    \ \n        output = main.execute(\"export\").toLowerCase();\n        if (!output.contains(\"\
    file name\")) {\n            return CheckResult.wrong(\"Your program should prompt\
    \ the user for the name of the file with the message \" +\n                  \
    \  \"\\\"File name:\\\"\");\n        }\n        \n        output = main.execute(capitalsFile);\n\
    \        if (!output.contains(\"2 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were exported. Expected 2\");\n        }\n        \n   \
    \     if (!output.contains(\"saved\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were exported with the message\
    \ \" +\n                    \"\\\"n cards have been saved.\\\" where \\\"n\\\"\
    \ is the number of cards exported\");\n        }\n        \n        fileExists\
    \ = checkFileExistence(capitalsFile);\n        if (!fileExists) {\n          \
    \  return CheckResult.wrong(\"Your program did not save a file after exporting\"\
    );\n        }\n        \n        empty = isEmpty(capitalsFile);\n        if (empty)\
    \ {\n            return CheckResult.wrong(\"The file your program saves is empty\"\
    );\n        }\n        \n        lines = output.split(\"\\n\");\n        lastLine\
    \ = lines[lines.length - 1];\n        if (!lastLine.toLowerCase().contains(\"\
    input the action\")) {\n            return CheckResult.wrong(\"Your program should\
    \ continue to request an action from the user until they \" +\n              \
    \      \"enter \\\"exit\\\"\");\n        }\n    \n        output = main.execute(\"\
    exit\").toLowerCase();\n        if (!output.contains(\"bye\")) {\n           \
    \ return CheckResult.wrong(\"Your program should print \\\"Bye bye!\\\" and terminate\
    \ if the user enters \" +\n                    \"\\\"exit\\\"\");\n        }\n\
    \    \n        if (!main.isFinished()) {\n            return CheckResult.wrong(\"\
    Your program should terminate if the user enters \\\"exit\\\"\");\n        }\n\
    \        \n        return CheckResult.correct();\n    }\n    \n    //saves file\
    \ for the next test\n    @DynamicTestingMethod\n    CheckResult test5() {\n  \
    \      TestedProgram main = new TestedProgram(Main.class);\n        main.start();\n\
    \        \n        String output;\n        boolean fileExists;\n        boolean\
    \ empty;\n        \n        for (int i = 0; i < listOfCountries.size(); i++) {\n\
    \            main.execute(\"add\");\n            main.execute(listOfCountries.get(i));\n\
    \            main.execute(listOfCapitals.get(i));\n        }\n        \n     \
    \   main.execute(\"export\");\n        output = main.execute(capitalsNewFile).toLowerCase();\n\
    \        if (!output.contains(\"6 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were exported. Expected 6\");\n        }\n        \n   \
    \     if (!output.contains(\"saved\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were exported with the message\"\
    \ +\n                    \" \\\"n cards have been saved.\\\" where \\\"n\\\" is\
    \ the number of cards exported\");\n        }\n        \n        fileExists =\
    \ checkFileExistence(capitalsNewFile);\n        if (!fileExists) {\n         \
    \   return CheckResult.wrong(\"Your program did not save a file after exporting\"\
    );\n        }\n        \n        empty = isEmpty(capitalsNewFile);\n        if\
    \ (empty) {\n            return CheckResult.wrong(\"The file your program saves\
    \ is empty\");\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should terminate if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check \"import\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test6() {\n        TestedProgram main = new TestedProgram(Main.class);\n\
    \        main.start();\n        \n        String output;\n        String lastLine;\n\
    \        String[] lines;\n        boolean fileExists;\n        boolean empty;\n\
    \        \n        output = main.execute(\"import\").toLowerCase();\n        if\
    \ (!output.contains(\"file name\")) {\n            return CheckResult.wrong(\"\
    Your program should prompt the user for the name of the file with the message\
    \ \" +\n                    \"\\\"File name:\\\"\");\n        }\n        \n  \
    \      String nonExistentFile = \"ghost_file.txt\";\n        output = main.execute(nonExistentFile).toLowerCase();\n\
    \        if (!output.contains(\"not found\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the file does not exist with the message\"\
    \ +\n                    \" \\\"File not found.\\\"\");\n        }\n        \n\
    \        lines = output.split(\"\\n\");\n        lastLine = lines[lines.length\
    \ - 1];\n        if (!lastLine.toLowerCase().contains(\"input the action\")) {\n\
    \            return CheckResult.wrong(\"Your program should continue to request\
    \ an action from the user until they \" +\n                    \"enter \\\"exit\\\
    \"\");\n        }\n        \n        main.execute(\"import\");\n        output\
    \ = main.execute(capitalsFile).toLowerCase();\n        if (output.contains(\"\
    not found\")) {\n            return CheckResult.wrong(\"You should be able to\
    \ import a file that you previously saved.\");\n        }\n        \n        if\
    \ (!output.contains(\"2 cards\")) {\n            return CheckResult.wrong(\"Wrong\
    \ number of cards were imported. Expected 2\");\n        }\n        \n       \
    \ if (!output.contains(\"been loaded\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were imported with the message\"\
    \ +\n                    \" \\\"n cards have been loaded.\\\" where \\\"n\\\"\
    \ is the number of cards in the file\");\n        }\n        \n        lines =\
    \ output.split(\"\\n\");\n        lastLine = lines[lines.length - 1];\n      \
    \  if (!lastLine.toLowerCase().contains(\"input the action\")) {\n           \
    \ return CheckResult.wrong(\"Your program should continue to request an action\
    \ from the user until they \" +\n                    \"enter \\\"exit\\\"\");\n\
    \        }\n        \n        main.execute(\"remove\");\n        output = main.execute(\"\
    Japan\").toLowerCase();\n        if (!output.contains(\"card has been removed\"\
    )) {\n            return CheckResult.wrong(\"You should be able to remove a card\
    \ that you imported from a file\");\n        }\n        \n        main.execute(\"\
    export\");\n        output = main.execute(capitalsFile).toLowerCase();\n     \
    \   if (!output.contains(\"1 card\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were exported. Expected 1\");\n        }\n        \n   \
    \     main.execute(\"import\");\n        output = main.execute(capitalsNewFile).toLowerCase();\n\
    \        if (!output.contains(\"6 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were imported. Expected 6\");\n        }\n        \n   \
    \     main.execute(\"export\");\n        output = main.execute(capitalsNewFile).toLowerCase();\n\
    \        if (!output.contains(\"7 cards\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were exported. Expected 7\");\n        }\n        \n   \
    \     fileExists = checkFileExistence(capitalsNewFile);\n        if (!fileExists)\
    \ {\n            return CheckResult.wrong(\"Your program did not save a file after\
    \ exporting\");\n        }\n        \n        empty = isEmpty(capitalsNewFile);\n\
    \        if (empty) {\n            return CheckResult.wrong(\"The file your program\
    \ saves is empty\");\n        }\n    \n        output = main.execute(\"exit\"\
    ).toLowerCase();\n        if (!output.contains(\"bye\")) {\n            return\
    \ CheckResult.wrong(\"Your program should print \\\"Bye bye!\\\" and terminate\
    \ if the user enters \" +\n                    \"\\\"exit\\\"\");\n        }\n\
    \    \n        if (!main.isFinished()) {\n            return CheckResult.wrong(\"\
    Your program should terminate if the user enters \\\"exit\\\"\");\n        }\n\
    \        \n        return CheckResult.correct();\n    }\n    \n    //Test to check\
    \ \"ask\" action\n    @DynamicTestingMethod\n    CheckResult test7() {\n     \
    \   TestedProgram main = new TestedProgram(Main.class);\n        main.start();\n\
    \        \n        String output;\n        String lastLine;\n        String[]\
    \ lines;\n        \n        main.execute(\"add\");\n        main.execute(\"France\"\
    );\n        main.execute(\"Eiffel Tower\");\n        \n        main.execute(\"\
    import\");\n        output = main.execute(capitalsFile).toLowerCase();\n     \
    \   if (!output.contains(\"1 card\")) {\n            return CheckResult.wrong(\"\
    Wrong number of cards were imported. Expected 1\");\n        }\n        \n   \
    \     if (!output.contains(\"been loaded\")) {\n            return CheckResult.wrong(\"\
    Your program should notify the user if the cards were imported with the message\"\
    \ +\n                    \" \\\"n cards have been loaded.\\\" where \\\"n\\\"\
    \ is the number of cards in the file\");\n        }\n        \n        output\
    \ = main.execute(\"ask\").toLowerCase();\n        if (!output.contains(\"times\"\
    )) {\n            return CheckResult.wrong(\"Your program should prompt the user\
    \ for the number of cards they want to be \" +\n                    \"asked about\
    \ with the message \\\"How many times to ask?\\\"\");\n        }\n        \n \
    \       \n        output = main.execute(\"1\").toLowerCase();\n        if (!output.contains(\"\
    \\\"france\\\"\")) {\n            return CheckResult.wrong(\"Your program should\
    \ print the definition requested for in quotes\");\n        }\n        \n    \
    \    if (!output.contains(\"definition\")) {\n            return CheckResult.wrong(\"\
    Your program should prompt the user for the definition of a card with the \" +\n\
    \                    \"message \\\" Print the definition of \\\"term\\\": where\
    \ \\\"term\\\" is the term of the flashcard to be \" +\n                    \"\
    checked\");\n        }\n        \n        output = main.execute(\"Eiffel Tower\"\
    ).toLowerCase();\n        if (output.equals(\"correct!\")) {\n            return\
    \ CheckResult.wrong(\"If the program's memory already has a card that is also\
    \ contained in the file \" +\n                    \"imported, then the definition\
    \ of the card from the file should overwrite the one in the \" +\n           \
    \         \"program's memory\");\n        }\n        \n        if (!output.contains(\"\
    wrong. the right answer is \\\"paris\\\"\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Wrong\\\" followed by the correct definition in\
    \ quotes\" +\n                    \" if the user inputs the wrong definition\"\
    );\n        }\n        \n        lines = output.split(\"\\n\");\n        lastLine\
    \ = lines[lines.length - 1];\n        if (!lastLine.toLowerCase().contains(\"\
    input the action\")) {\n            return CheckResult.wrong(\"Your program should\
    \ request an action from the user if there are no more cards \" +\n          \
    \          \"to ask\");\n        }\n        \n        main.execute(\"ask\");\n\
    \        main.execute(\"1\");\n        output = main.execute(\"Paris\").toLowerCase();\n\
    \        lines = output.split(\"\\n\");\n        \n        if (!lines[0].equals(\"\
    correct!\")) {\n            return CheckResult.wrong(\"Your program should print\
    \ \\\"Correct!\\\" if the user inputs the correct \" +\n                    \"\
    definition\");\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should terminate if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test8() {\n        TestedProgram\
    \ main = new TestedProgram(Main.class);\n        main.start();\n        \n   \
    \     int index;\n        String output;\n        String term;\n        String\
    \ lastLine;\n        String[] lines;\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++) {\n            main.execute(\"add\");\n            main.execute(listOfTerms.get(i));\n\
    \            main.execute(listOfDefinitions.get(i));\n        }\n        \n  \
    \      main.execute(\"ask\");\n        output = main.execute(\"6\").toLowerCase();\n\
    \        term = getTerm(output);\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++){\n            index = listOfTerms.indexOf(term);\n            System.out.println(\"\
    Index: \" + index);\n            \n            output = main.execute(listOfDefinitions.get(index)).toLowerCase();\n\
    \            lines = output.split(\"\\n\");\n            lastLine = lines[lines.length\
    \ - 1];\n            \n            if (!lines[0].equals(\"correct!\")) {\n   \
    \             return CheckResult.wrong(\"Your program should print \\\"Correct!\\\
    \" if the user inputs the correct\" +\n                        \" definition\"\
    );\n            }\n            \n            if (i == listOfTerms.size() - 1)\
    \ {\n                \n                if (!lastLine.toLowerCase().contains(\"\
    input the action\")) {\n                    return CheckResult.wrong(\"Your program\
    \ should request an action from the user if there are no more cards \" +\n   \
    \                         \"to ask\");\n                }\n            } else\
    \ {\n                term = getTerm(lastLine);\n            }\n            \n\
    \        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n   \
    \     if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should terminate if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test9() {\n        TestedProgram\
    \ main = new TestedProgram(Main.class);\n        main.start();\n        \n   \
    \     int index;\n        String output;\n        String term;\n        String\
    \ lastLine;\n        String[] lines;\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++) {\n            main.execute(\"add\");\n            main.execute(listOfTerms.get(i));\n\
    \            main.execute(listOfDefinitions.get(i));\n        }\n        \n  \
    \      main.execute(\"ask\");\n        output = main.execute(\"6\").toLowerCase();\n\
    \        term = getTerm(output);\n        \n        for (int i = 0; i < listOfTerms.size();\
    \ i++){\n            index = listOfTerms.indexOf(term);\n            \n      \
    \      output = main.execute(listOfAddedDefinitions.get(index)).toLowerCase();\n\
    \            lines = output.split(\"\\n\");\n            lastLine = lines[lines.length\
    \ - 1];\n            \n            if (!lines[0].contains(\"wrong. the right answer\
    \ is \\\"\" + listOfDefinitions.get(index) + \"\\\"\")) {\n                return\
    \ CheckResult.wrong(\"Your program should print \\\"Wrong\\\" followed by the\
    \ correct definition\" +\n                        \" in quotes if the user inputs\
    \ the wrong definition\");\n            }\n            \n            if (i ==\
    \ listOfTerms.size() - 1) {\n                \n                if (!lastLine.toLowerCase().contains(\"\
    input the action\")) {\n                    return CheckResult.wrong(\"Your program\
    \ should request an action from the user if there are no more cards \" +\n   \
    \                         \"to ask\");\n                }\n            } else\
    \ {\n                term = getTerm(lastLine);\n            }\n            \n\
    \        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n   \
    \     if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should terminate if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test10() {\n        TestedProgram\
    \ main = new TestedProgram(Main.class);\n        main.start();\n        \n   \
    \     int wrongIndex;\n        int index;\n        String output;\n        String\
    \ term;\n        String lastLine;\n        String[] lines;\n        \n       \
    \ for (int i = 0; i < listOfTerms.size(); i++) {\n            main.execute(\"\
    add\");\n            main.execute(listOfTerms.get(i));\n            main.execute(listOfDefinitions.get(i));\n\
    \        }\n        \n        main.execute(\"ask\");\n        output = main.execute(\"\
    6\").toLowerCase();\n        term = getTerm(output);\n        \n        for (int\
    \ i = 0; i < listOfTerms.size(); i++){\n            index = listOfTerms.indexOf(term);\n\
    \            \n            if (index % 2 == 0) {\n                wrongIndex =\
    \ index + 1;\n            } else {\n                wrongIndex = index - 1;\n\
    \            }\n            \n            output = main.execute(listOfDefinitions.get(wrongIndex)).toLowerCase();\n\
    \            lines = output.split(\"\\n\");\n            lastLine = lines[lines.length\
    \ - 1];\n            \n            if (!lines[0].contains(\"wrong. the right answer\
    \ is \\\"\" + listOfDefinitions.get(index) + \"\\\"\")) {\n                return\
    \ CheckResult.wrong(\"Your program should print \\\"Wrong\\\" followed by the\
    \ correct definition\" +\n                        \" in quotes if the user inputs\
    \ the wrong definition\");\n            }\n            \n            if (!lines[0].contains(\"\
    correct for \\\"\" + listOfTerms.get(wrongIndex) + \"\\\"\")) {\n            \
    \    return CheckResult.wrong(\"Your output should also contain \\\"but your definition\
    \ is correct for 'term'\" +\n                        \" \\\"\");\n           \
    \ }\n            \n            if (i == listOfTerms.size() - 1) {\n          \
    \      \n                if (!lastLine.toLowerCase().contains(\"input the action\"\
    )) {\n                    return CheckResult.wrong(\"Your program should request\
    \ an action from the user if there are no more cards \" +\n                  \
    \          \"to ask\");\n                }\n            } else {\n           \
    \     term = getTerm(lastLine);\n            }\n            \n        }\n    \n\
    \        output = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"\
    bye\")) {\n            return CheckResult.wrong(\"Your program should print \\\
    \"Bye bye!\\\" and terminate if the user enters \" +\n                    \"\\\
    \"exit\\\"\");\n        }\n    \n        if (!main.isFinished()) {\n         \
    \   return CheckResult.wrong(\"Your program should terminate if the user enters\
    \ \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check the \"hardest card\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test11() {\n        TestedProgram main = new TestedProgram(Main.class);\n\
    \        main.start();\n        \n        String output;\n        String lastLine;\n\
    \        String[] lines;\n        \n        output = main.execute(\"hardest card\"\
    ).toLowerCase();\n        lines = output.split(\"\\n\");\n        lastLine = lines[lines.length\
    \ -1];\n        \n        if (!output.contains(\"no cards with errors\")) {\n\
    \            return CheckResult.wrong(\"Your program should print \\\"There are\
    \ no cards with errors.\\\" if there are no \" +\n                    \"cards\
    \ with errors\");\n        }\n        \n        if (!lastLine.toLowerCase().contains(\"\
    input the action\")) {\n            return CheckResult.wrong(\"Your program should\
    \ continue to request an action from the user until they enter\" +\n         \
    \           \" \\\"exit\\\"\");\n        }\n        \n        main.execute(\"\
    add\");\n        main.execute(\"France\");\n        main.execute(\"Paris\");\n\
    \        \n        main.execute(\"ask\");\n        main.execute(\"1\");\n    \
    \    main.execute(\"Eiffel Tower\");\n        \n        main.execute(\"ask\");\n\
    \        main.execute(\"1\");\n        main.execute(\"Lyon\");\n        \n   \
    \     output = main.execute(\"hardest card\").toLowerCase();\n        if (!output.contains(\"\
    the hardest card is\")) {\n            return CheckResult.wrong(\"Your program\
    \ should show the user the hardest card(s) in the format\" +\n               \
    \     \" \\\"The hardest card is \\\"card\\\". You have n errors answering it.\\\
    \"\");\n        }\n        \n        if (!output.contains(\"errors answering it\"\
    )) {\n            return CheckResult.wrong(\"Your program should show the user\
    \ the hardest card(s) in the format\" +\n                    \" \\\"The hardest\
    \ card is \\\"card\\\". You have n errors answering it.\\\"\");\n        }\n \
    \   \n        if (!output.contains(\"\\\"france\\\"\")) {\n            return\
    \ CheckResult.wrong(\"Your program should print the hardest card in quotes\");\n\
    \        }\n        \n        if (!output.contains(\"2\")) {\n            return\
    \ CheckResult.wrong(\"Your program shows wrong number of errors. Expected 2\"\
    );\n        }\n        \n        main.execute(\"export\");\n        main.execute(capitalsFile);\n\
    \    \n        output = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"\
    bye\")) {\n            return CheckResult.wrong(\"Your program should print \\\
    \"Bye bye!\\\" and terminate if the user enters \" +\n                    \"\\\
    \"exit\\\"\");\n        }\n    \n        if (!main.isFinished()) {\n         \
    \   return CheckResult.wrong(\"Your program should terminate if the user enters\
    \ \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test12() {\n        TestedProgram\
    \ main = new TestedProgram(Main.class);\n        main.start();\n    \n       \
    \ String output;\n        \n        main.execute(\"add\");\n        main.execute(\"\
    Russia\");\n        main.execute(\"Moscow\");\n        \n        main.execute(\"\
    ask\");\n        main.execute(\"1\");\n        main.execute(\"Saint Petersburg\"\
    );\n    \n        main.execute(\"ask\");\n        main.execute(\"1\");\n     \
    \   main.execute(\"Saint Petersburg\");\n    \n        main.execute(\"ask\");\n\
    \        main.execute(\"1\");\n        main.execute(\"Saint Petersburg\");\n \
    \   \n        output = main.execute(\"hardest card\").toLowerCase();\n       \
    \ if (!output.contains(\"the hardest card is\")) {\n            return CheckResult.wrong(\"\
    Your program should show the user the hardest card(s) in the format\" +\n    \
    \                \" \\\"The hardest card is \\\"card\\\". You have n errors answering\
    \ it.\\\"\");\n        }\n    \n        if (!output.contains(\"errors answering\
    \ it\")) {\n            return CheckResult.wrong(\"Your program should show the\
    \ user the hardest card(s) in the format\" +\n                    \" \\\"The hardest\
    \ card is \\\"card\\\". You have n errors answering it.\\\"\");\n        }\n \
    \   \n        if (!output.contains(\"\\\"russia\\\"\")) {\n            return\
    \ CheckResult.wrong(\"Your program should print the hardest card in quotes\");\n\
    \        }\n    \n        if (!output.contains(\"3\")) {\n            return CheckResult.wrong(\"\
    Your program shows wrong number of errors. Expected 3\");\n        }\n    \n \
    \       main.execute(\"export\");\n        main.execute(capitalsNewFile);\n  \
    \  \n        output = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"\
    bye\")) {\n            return CheckResult.wrong(\"Your program should print \\\
    \"Bye bye!\\\" and terminate if the user enters \" +\n                    \"\\\
    \"exit\\\"\");\n        }\n    \n        if (!main.isFinished()) {\n         \
    \   return CheckResult.wrong(\"Your program should terminate if the user enters\
    \ \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test13() {\n        TestedProgram\
    \ main = new TestedProgram(Main.class);\n        main.start();\n    \n       \
    \ String output;\n        \n        main.execute(\"import\");\n        main.execute(capitalsFile);\n\
    \        \n        main.execute(\"import\");\n        main.execute(capitalsNewFile);\n\
    \        \n        output = main.execute(\"hardest card\").toLowerCase();\n  \
    \      if (output.contains(\"no cards with errors\")) {\n            return CheckResult.wrong(\"\
    Your program should print the hardest card(s) if such card(s) exists\");\n   \
    \     }\n    \n        if (!output.contains(\"the hardest card is\")) {\n    \
    \        return CheckResult.wrong(\"Your program should show the user the hardest\
    \ card(s) in the format\" +\n                    \" \\\"The hardest card is \\\
    \"card\\\". You have n errors answering it.\\\"\");\n        }\n    \n       \
    \ if (!output.contains(\"errors answering it\")) {\n            return CheckResult.wrong(\"\
    Your program should show the user the hardest card(s) in the format\" +\n    \
    \                \" \\\"The hardest card is \\\"card\\\". You have n errors answering\
    \ it.\\\"\");\n        }\n        \n        if (output.contains(\"france\")) {\n\
    \            return CheckResult.wrong(\"Your program printed the wrong card\"\
    );\n        }\n    \n        if (!output.contains(\"\\\"russia\\\"\")) {\n   \
    \         return CheckResult.wrong(\"Your program should print the hardest card\
    \ in quotes\");\n        }\n    \n        if (!output.contains(\"3\")) {\n   \
    \         return CheckResult.wrong(\"Your program shows wrong number of errors.\
    \ Expected 3\");\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should terminate if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    @DynamicTestingMethod\n    CheckResult test14() {\n        TestedProgram\
    \ main = new TestedProgram(Main.class);\n        main.start();\n    \n       \
    \ String output;\n        \n        main.execute(\"import\");\n        main.execute(capitalsFile);\n\
    \        \n        main.execute(\"ask\");\n        main.execute(\"1\");\n    \
    \    main.execute(\"Lyon\");\n        \n        main.execute(\"import\");\n  \
    \      main.execute(capitalsNewFile);\n        \n        output = main.execute(\"\
    hardest card\").toLowerCase();\n        if (output.contains(\"no cards with errors\"\
    )) {\n            return CheckResult.wrong(\"Your program should print the hardest\
    \ card(s) if such card(s) exists\");\n        }\n    \n        if (!output.contains(\"\
    hardest cards are\")) {\n            return CheckResult.wrong(\"Your program should\
    \ show the user the hardest card(s) in the format\" +\n                    \"\
    \ \\\"The hardest cards are \\\"card#1\\\", \\\"card#2\\\"...\\\"card#n\\\". You\
    \ have n errors answering them\" +\n                    \".\\\"\");\n        }\n\
    \    \n        if (!output.contains(\"errors answering them\")) {\n          \
    \  return CheckResult.wrong(\"Your program should show the user the hardest card(s)\
    \ in the format \\\"The \" +\n                    \"hardest cards are \\\"card#1\\\
    \", \\\"card#2\\\"...\\\"card#n\\\". You have n errors answering them\\\".\");\n\
    \        }\n        \n        if (!output.contains(\"france\")) {\n          \
    \  return CheckResult.wrong(\"Your program should print all the cards with the\
    \ highest number of errors\");\n        }\n    \n        if (!output.contains(\"\
    russia\")) {\n            return CheckResult.wrong(\"Your program should print\
    \ all the cards with the highest number of errors\");\n        }\n    \n     \
    \   if (!output.contains(\"\\\"france\\\"\")) {\n            return CheckResult.wrong(\"\
    Your program should print the hardest card(s) in quotes\");\n        }\n    \n\
    \        if (!output.contains(\"\\\"russia\\\"\")) {\n            return CheckResult.wrong(\"\
    Your program should print the hardest card(s) in quotes\");\n        }\n    \n\
    \        output = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"\
    bye\")) {\n            return CheckResult.wrong(\"Your program should print \\\
    \"Bye bye!\\\" and terminate if the user enters \" +\n                    \"\\\
    \"exit\\\"\");\n        }\n    \n        if (!main.isFinished()) {\n         \
    \   return CheckResult.wrong(\"Your program should terminate if the user enters\
    \ \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check the \"reset stats\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test15() {\n        TestedProgram main = new TestedProgram(Main.class);\n\
    \        main.start();\n    \n        String output;\n        \n        main.execute(\"\
    hardest card\");\n        \n        main.execute(\"import\");\n        main.execute(capitalsFile);\n\
    \        \n        main.execute(\"hardest card\");\n        \n        main.execute(\"\
    ask\");\n        main.execute(\"1\");\n        main.execute(\"Tokyo\");\n    \
    \    \n        main.execute(\"hardest card\");\n    \n        main.execute(\"\
    import\");\n        main.execute(capitalsNewFile);\n        \n        output =\
    \ main.execute(\"reset stats\").toLowerCase();\n        if (!output.contains(\"\
    statistics have been reset\")) {\n            return CheckResult.wrong(\"Your\
    \ program should notify the user if the stats have been reset with the \" +\n\
    \                    \"message \\\"Card statistics have been reset.\\\"\");\n\
    \        }\n        \n        output = main.execute(\"hardest card\").toLowerCase();\n\
    \        if (!output.contains(\"no cards with errors\")) {\n            return\
    \ CheckResult.wrong(\"Your program should reset the errors of all the cards back\
    \ to zero\");\n        }\n    \n        output = main.execute(\"exit\").toLowerCase();\n\
    \        if (!output.contains(\"bye\")) {\n            return CheckResult.wrong(\"\
    Your program should print \\\"Bye bye!\\\" and terminate if the user enters \"\
    \ +\n                    \"\\\"exit\\\"\");\n        }\n    \n        if (!main.isFinished())\
    \ {\n            return CheckResult.wrong(\"Your program should terminate if the\
    \ user enters \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    //Test to check the \"log\" action\n    @DynamicTestingMethod\n\
    \    CheckResult test16() {\n        TestedProgram main = new TestedProgram(Main.class);\n\
    \        main.start();\n    \n        String output;\n    \n        main.execute(\"\
    hardest card\");\n    \n        main.execute(\"import\");\n        main.execute(capitalsFile);\n\
    \    \n        main.execute(\"hardest card\");\n    \n        main.execute(\"\
    ask\");\n        main.execute(\"1\");\n        main.execute(\"Tokyo\");\n    \n\
    \        main.execute(\"hardest card\");\n    \n        output = main.execute(\"\
    reset stats\").toLowerCase();\n        if (!output.contains(\"statistics have\
    \ been reset\")) {\n            return CheckResult.wrong(\"Your program should\
    \ notify the user if the stats have been reset with the \" +\n               \
    \     \"message \\\"Card statistics have been reset.\\\"\");\n        }\n    \n\
    \        output = main.execute(\"hardest card\").toLowerCase();\n        if (!output.contains(\"\
    no cards with errors\")) {\n            return CheckResult.wrong(\"Your program\
    \ should reset the errors of all the cards back to zero\");\n        }\n    \n\
    \        output = main.execute(\"log\").toLowerCase();\n        if (!output.contains(\"\
    file name\")) {\n            return CheckResult.wrong(\"Your program should prompt\
    \ the user for the name of the file to be saved with \" +\n                  \
    \  \"the message \\\"File name:\\\"\");\n        }\n        \n        output =\
    \ main.execute(\"todayLog.txt\").toLowerCase();\n        if (!output.contains(\"\
    log has been saved\")){\n            return CheckResult.wrong(\"Your program should\
    \ notify the user if the log file was saved with the message\" +\n           \
    \         \" \\\"The log has been saved.\\\"\");\n        }\n        \n      \
    \  boolean fileExists = checkFileExistence(\"todayLog.txt\");\n        if (!fileExists)\
    \ {\n            return CheckResult.wrong(\"Your program did not save the log\
    \ file\");\n        }\n        \n        boolean validContent = checkLogFileLength(\"\
    todayLog.txt\");\n        if (!validContent) {\n            return CheckResult.wrong(\"\
    The number of lines your program saves is less than the number of lines that \"\
    \ +\n                    \"was input/output to the console\");\n        }\n  \
    \  \n        output = main.execute(\"exit\").toLowerCase();\n        if (!output.contains(\"\
    bye\")) {\n            return CheckResult.wrong(\"Your program should print \\\
    \"Bye bye!\\\" and terminate if the user enters \" +\n                    \"\\\
    \"exit\\\"\");\n        }\n    \n        if (!main.isFinished()) {\n         \
    \   return CheckResult.wrong(\"Your program should terminate if the user enters\
    \ \\\"exit\\\"\");\n        }\n        \n        return CheckResult.correct();\n\
    \    }\n    \n    private boolean checkLogFileLength(String fileName) {\n    \
    \    int lineCount = 0;\n        int minimumLineExpected = 32;\n    \n       \
    \ File file = new File(fileName);\n        try (BufferedReader reader = new BufferedReader(new\
    \ FileReader(file))) {\n        \n            while (reader.readLine() != null)\
    \ {\n                lineCount++;\n            }\n        }catch (IOException\
    \ e) {}\n        \n        return minimumLineExpected < lineCount;\n    }\n  \
    \  \n    private boolean checkFileExistence(String fileName) {\n        File file\
    \ = new File(fileName);\n        return file.exists();\n    }\n    \n    private\
    \ boolean isEmpty(String fileName) {\n        int lineCount = 0;\n        \n \
    \       File file = new File(fileName);\n        try (BufferedReader reader =\
    \ new BufferedReader(new FileReader(file))) {\n            \n            while\
    \ (reader.readLine() != null) {\n                lineCount++;\n            }\n\
    \        }catch (IOException e) {}\n        \n        return lineCount <= 0;\n\
    \    }\n    \n    private String getTerm(String output) {\n        int start =\
    \ output.indexOf(\"\\\"\");\n        int end = output.lastIndexOf(\"\\\"\");\n\
    \        \n        return output.substring((start + 1), end);\n    }\n    \n \
    \   private static List<String> getListOfTerms() {\n        return Arrays.asList(\n\
    \                \"print()\",\n                \"str()\",\n                \"\
    son\",\n                \"daughter\",\n                \"uncle\",\n          \
    \      \"ankle\");\n    }\n    \n    private static List<String> getListOfDefinitions()\
    \ {\n        return Arrays.asList(\n                \"outputs text\",\n      \
    \          \"converts to a string\",\n                \"a male child\",\n    \
    \            \"a female child\",\n                \"a brother of one's parent\"\
    ,\n                \"a part of the body where the foot and the leg meet\"\n  \
    \      );\n    }\n    \n    //Extra wrongs invalidate the definition\n    private\
    \ static List<String> getListOfWrongDefinitions1() {\n        return Arrays.asList(\n\
    \                \"outputs text line by line\",\n                \"converts to\
    \ a string and an integer\",\n                \"a male child or a female child\"\
    ,\n                \"a female child or a male child\",\n                \"a brother\
    \ of one's parent or grandparents\",\n                \"a part of the body where\
    \ the foot and the leg meet or the arm\"\n        );\n    }\n    \n    private\
    \ static List<String> getListOfCountries() {\n        return Arrays.asList(\n\
    \                \"Canada\",\n                \"Netherlands\",\n             \
    \   \"Russia\",\n                \"United Kingdom\",\n                \"Nigeria\"\
    ,\n                \"Germany\"\n        );\n    }\n    \n    private static List<String>\
    \ getListOfCapitals() {\n        return Arrays.asList(\n                \"Ottawa\"\
    ,\n                \"Amsterdam\",\n                \"Moscow\",\n             \
    \   \"London\",\n                \"Abuja\",\n                \"Berlin\"\n    \
    \    );\n    }\n    \n}\n\n\n\n\n"
  learner_created: false
- name: test/common/FlashcardsStage5Test.kt
  visible: false
  text: "package common\n\nimport org.hyperskill.hstest.stage.StageTest\nimport org.hyperskill.hstest.testcase.CheckResult\n\
    import org.hyperskill.hstest.testcase.TestCase\nimport flashcards.Main\n\nabstract\
    \ class FlashcardsStage5Test : StageTest<DialogClue>(Main::class.java) {\n\n \
    \   // how to remove files? Now at least rewrite in the first test:\n    override\
    \ fun generate(): List<TestCase<DialogClue>> {\n        val tests = mutableListOf<TestCase<DialogClue>>()\n\
    \        // old tests:\n        tests += dialogTest(\n                addCard(\"\
    black\", \"white\"),\n                existingCard(\"black\"),\n             \
    \   existingDef(\"red\", \"white\"),\n                askCards(\"white\", \"green\"\
    ), // the ask order is random\n                exit()\n        )\n        tests\
    \ += dialogTest(\n                addCard(\"a brother of one's parent\", \"uncle\"\
    ),\n                addCard(\"a part of the body where the foot and the leg meet\"\
    , \"ankle\"),\n                askCards(\"ankle\", \"??\", \"uncle\", \"ankle\"\
    , \"??\", \"uncle\"), // the ask order is random\n                exit()\n   \
    \     )\n        // stage 5 tests:\n\n        val capitalList = mutableListOf<Pair<String,\
    \ String>>()\n        fun capitals() = capitalList.toTypedArray()\n\n        //\
    \ wrappers for add/remove card, but saving cards to capitalList:\n        fun\
    \ addCapital(card: String, def: String) = addCard(card, def)\n               \
    \ .also { capitalList += card to def }\n\n        fun removeCapitalCard(card:\
    \ String) = removeCard(card)\n                .also { capitalList.removeIf { it.first\
    \ == card } }\n\n        // testing files\n        // clear files\n        tests\
    \ += dialogTest(\n                exportCards(\"capitals.txt\", 0),\n        \
    \        exportCards(\"capitalsNew.txt\", 0),\n                exit()\n      \
    \  )\n        tests += dialogTest(\n                importNonExisting(\"ghost_file.txt\"\
    ),\n                exit()\n        )\n        tests += dialogTest(\n        \
    \        addCapital(\"Great Britain\", \"London\"),\n                removeNonExisting(\"\
    Wakanda\"),\n                exportCards(\"capitals.txt\", 1),\n             \
    \   importCards(\"capitals.txt\", *capitals()),\n                askCards(\"London\"\
    ),\n                exportCards(\"capitalsNew.txt\", 1),\n                exit()\n\
    \        )\n        tests += dialogTest(\n                importCards(\"capitalsNew.txt\"\
    , *capitals()), // import checks only the amount of cards\n                exit()\n\
    \        )\n        tests += dialogTest(\n                importCards(\"capitalsNew.txt\"\
    , *capitals()),\n                addCapital(\"France\", \"Paris\"),\n        \
    \        addCapital(\"Russia\", \"Moscow\"),\n                removeCapitalCard(\"\
    Great Britain\"),\n                exportCards(\"capitalsNew.txt\", 2),\n    \
    \            importCards(\"capitalsNew.txt\", *capitals()),\n                askCards(\"\
    London\", \"Paris\", \"Moscow\", \"Paris\"),\n                exit()\n       \
    \ )\n        // check merge with file import\n        tests += dialogTest(\n \
    \               addCard(\"Japan\", \"Tokyo\"), // should be merged\n         \
    \       addCard(\"France\", \"UpdateMeFromImport\"), // should be updated from\
    \ import file\n                addCard(\"Russia\", \"UpdateMeFromImport2\"), //\
    \ should be updated from import file\n                importCards(\"capitalsNew.txt\"\
    , *capitals()),\n                askCards(\"Tokyo\", \"Paris\", \"Moscow\"),\n\
    \                removeCard(\"Japan\"),\n                removeCapitalCard(\"\
    Russia\"),\n                exportCards(\"capitalsNew.txt\", 1), // only France\
    \ left\n                exit()\n        )\n\n        // check reverse map while\
    \ merge\n        tests += dialogTest(\n                addCard(\"France\", \"\
    UpdateMeFromImport\"), // should be updated from import file\n               \
    \ importCards(\"capitalsNew.txt\", *capitals()),\n                askCards(\"\
    UpdateMeFromImport\"), // check that we removed from reverse map\n           \
    \     exit()\n        )\n        \n        // check remove, add and ask:\n   \
    \     tests += dialogTest(\n                addCard(\"a\", \"1\"),\n         \
    \       addCard(\"b\", \"2\"),\n                addCard(\"c\", \"3\"),\n     \
    \           existingCard(\"b\"),\n                existingCard(\"c\"),\n     \
    \           addCard(\"d\", \"4\"),\n                removeCard(\"c\"),\n     \
    \           removeNonExisting(\"xxxx\"),\n                addCard(\"c\", \"5\"\
    ),\n                existingDef(\"new card\", \"4\"),\n                existingDef(\"\
    f\", \"5\"),\n                removeCard(\"c\"),\n                removeCard(\"\
    d\"), // left only a and b\n                askCards(\"1\", \"2\", \"3\", \"4\"\
    , \"3\", \"2\", \"1\"), // try to fit random\n                askCards(\"2\"),\n\
    \                exit()\n        )\n        return tests\n    }\n\n    override\
    \ fun check(reply: String, clue: DialogClue): CheckResult {\n        return clue.checkOutput(reply)\n\
    \    }\n\n\n    // ------ extensions for building a dialog: ------\n\n    fun\
    \ inputAction(action: String) = compositePhrase {\n        listOf(containing(\"\
    action\", hint = \"This line should ask the action.\"), user(action))\n    }\n\
    \n    // extend dialog context with our own data:\n\n    @Suppress(\"UNCHECKED_CAST\"\
    )\n    private val Context.cardToDef\n        get() = rawData.getOrPut(\"cardToDef\"\
    ) { mutableMapOf<String, String>() } as MutableMap<String, String>\n\n    @Suppress(\"\
    UNCHECKED_CAST\")\n    private val Context.defToCard\n        get() = rawData.getOrPut(\"\
    defToCard\") { mutableMapOf<String, String>() } as MutableMap<String, String>\n\
    \n    private fun Context.addCard(card: String, definition: String) {\n      \
    \  cardToDef[card] = definition\n        defToCard[definition] = card\n    }\n\
    \n    private fun Context.removeCard(card: String) {\n        val def = cardToDef.remove(card)\n\
    \        if (def != null) {\n            defToCard.remove(def)\n        }\n  \
    \  }\n\n\n    private fun addCard(card: String, def: String) = compositePhrase(\n\
    \            inputAction(\"add\"),\n            anyLine(), user(card),\n     \
    \       anyLine(), user(def),\n            containing(\"has been added\",\n  \
    \                  hint = \"This line should add the pair (\\\"$card\\\":\\\"\
    $def\\\").\",\n                    updateContext = { ctx -> ctx.addCard(card,\
    \ def) })\n    )\n\n\n    private fun existingDef(card: String, def: String) =\
    \ compositePhrase(\n            inputAction(\"add\"),\n            anyLine(),\
    \ user(card),\n            anyLine(), user(def),\n            containing(\"definition\"\
    , \"exists\", hint = \"This line should reject the existing definition `$def`.\"\
    )\n    )\n\n\n    private fun existingCard(card: String) = compositePhrase(\n\
    \            inputAction(\"add\"),\n            anyLine(), user(card),\n     \
    \       containing(\"card\", \"exists\", hint = \"This line should reject the\
    \ existing card `$card`.\")\n    )\n\n    private fun removeCard(card: String)\
    \ = compositePhrase(\n            inputAction(\"remove\"),\n            anyLine(),\
    \ user(card),\n            containing(\"has been removed\", hint = \"This line\
    \ should remove the card `$card`.\",\n                    updateContext = { ctx\
    \ -> ctx.removeCard(card) })\n    )\n\n    private fun removeNonExisting(card:\
    \ String) = compositePhrase(\n            inputAction(\"remove\"),\n         \
    \   anyLine(), user(card),\n            containing(\"Can't remove \\\"$card\\\"\
    \", hint = \"This line should reject removing non existing card `$card`.\")\n\
    \    )\n\n\n    private fun importCards(fileName: String, vararg cards: Pair<String,\
    \ String>) = compositePhrase(\n            inputAction(\"import\"),\n        \
    \    anyLine(), user(fileName),\n            containing(\"${cards.size} cards\
    \ have been loaded\",\n                    updateContext = { ctx ->\n        \
    \                val cardToDef = ctx.cardToDef\n                        val defToCard\
    \ = ctx.defToCard\n                        cards.forEach { (card, def) ->\n  \
    \                          if (card in cardToDef) {\n                        \
    \        defToCard.remove(cardToDef[card]) // erase wrong reverse link\n     \
    \                       }\n                            ctx.addCard(card, def)\
    \ // with update!!\n                        }\n                    })\n    )\n\
    \n    private fun importNonExisting(fileName: String) = compositePhrase(\n   \
    \         inputAction(\"import\"),\n            anyLine(), user(fileName),\n \
    \           containing(\"not found\", hint = \"This line should say, that the\
    \ file $fileName does not exist.\")\n    )\n\n    private fun exportCards(fileName:\
    \ String, cardsSize: Int) = compositePhrase(\n            inputAction(\"export\"\
    ),\n            anyLine(), user(fileName),\n            containing(\"$cardsSize\
    \ cards have been saved\")\n    )\n\n    private fun exit() = compositePhrase(\n\
    \            inputAction(\"exit\"),\n            anyLine()\n    )\n\n    /** Perform\
    \ ask action. [ansDefs] are our test answers with definitions.\n     * We don't\
    \ know are they wrong or correct, because the test is random. */\n    private\
    \ fun askCards(vararg ansDefs: String) = compositePhrase {\n        val startPhrases\
    \ = listOf(\n                inputAction(\"ask\"),\n                anyLine(),\
    \ user(ansDefs.size.toString())\n        )\n        // here we add the dialog\
    \ logic, by creating base OutputLine class with a custom checker\n        // we\
    \ use context to connect with neighbor checkers\n\n        // iterate test answered\
    \ definitions:\n        val repeatingPhrases = ansDefs.map { ansDef ->\n     \
    \       compositePhrase(\n                    OutputLine { text, ctx ->\n    \
    \                    val askedCard = text.dropWhile { it != '\"' }.dropLastWhile\
    \ { it != '\"' }.trim('\"')\n                        if (askedCard.isEmpty())\
    \ {\n                            return@OutputLine CheckResult.wrong(\"Not found\
    \ card in quotes. \" +\n                                    \"This line should\
    \ ask the definition of a random card.\")\n                        }\n       \
    \                 if (askedCard !in ctx.cardToDef) {\n                       \
    \     return@OutputLine CheckResult.wrong(\"You asked the definition of the non\
    \ existing card: `$askedCard`.\")\n                        }\n               \
    \         ctx.rawData[\"lastAskedCard\"] = askedCard\n                       \
    \ CheckResult.correct();\n                    },\n                    // unfortunately\
    \ we can't access the Context in user action, see documentation of user()\n  \
    \                  user(ansDef),\n                    // check the answer:\n \
    \                   OutputLine { text, ctx ->\n                        val askedCard\
    \ = ctx.rawData[\"lastAskedCard\"]\n                                ?: throw IllegalStateException(\"\
    Not found lastAskedCard in the `ask` checker.\")\n                        val\
    \ cardToDef = ctx.cardToDef\n                        val defToCard = ctx.defToCard\n\
    \                        val rightAns = cardToDef[askedCard]\n\n             \
    \           val hint = \"The asked card was `$askedCard`, the answer was `$ansDef`.\"\
    \n                        if (cardToDef[askedCard] == ansDef)\n              \
    \              containing(\"Correct answer\", hint = hint).checker(text, ctx)\n\
    \                        else {\n                            val isDefFor = defToCard[ansDef]\n\
    \                            if (isDefFor != null) {\n                       \
    \         containing(\"Wrong answer\", \"The correct one is \\\"$rightAns\\\"\"\
    ,\n                                        \"you've just written the definition\
    \ of \\\"$isDefFor\\\"\", hint = hint).checker(text, ctx)\n                  \
    \          } else {\n                                // should not contain definition\
    \ hint!!\n                                if (text.contains(\"you've just written\
    \ the definition of\")) {\n                                    CheckResult.wrong(\"\
    Your line\\n`$text`\\nshould NOT contain \" +\n                              \
    \              \"`you've just written the definition of`.\\n$hint\")\n       \
    \                         } else {\n                                    containing(\"\
    Wrong answer\", \"The correct one is \\\"$rightAns\\\"\", hint = hint).checker(text,\
    \ ctx)\n                                }\n                                \n\
    \                            }\n                        }\n                  \
    \  }\n            )\n        }\n        (startPhrases + repeatingPhrases)\n  \
    \  }\n\n}\n\n"
  learner_created: false
- name: test/common/FlashcardsStage4Test.kt
  visible: false
  text: |
    package common

    import flashcards.Main
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult

    abstract class FlashcardsStage4Test : StageTest<DialogClue>(Main::class.java) {

        override fun generate() = listOf(
                dialogTest(
                        anyLine(), user("2"),
                        anyLine(), user("black"),
                        anyLine(), user("white"),
                        anyLine(), user("black"),
                        containing("The card \"black\" already exists"),
                        user("red"),
                        anyLine(), user("white"),
                        containing("The definition \"white\" already exists"),
                        user("green"),
                        // asking
                        askCorrect("black", "white"),
                        askCorrect("red", "green")
                ),
                dialogTest(
                        inputNum(2),
                        inputCard("a brother of one's parent", "uncle"),
                        inputCard("a part of the body where the foot and the leg meet", "ankle"),
                        // asking
                        askWrong("a brother of one's parent", userAns = "ankle", rightAns = "uncle",
                                isDefFor = "a part of the body where the foot and the leg meet"),

                        askWrong("a part of the body where the foot and the leg meet", "???", "ankle")
                ),
                dialogTest(
                        inputNum(4),
                        inputCard("c1", "d1"),
                        inputCard("c2", "d2"),
                        inputCard("c3", "d3"),
                        // repeating three times
                        anyLine(),
                        user("c3"), containing("The card \"c3\" already exists"),
                        user("c2"), containing("The card \"c2\" already exists"),
                        user("c1"), containing("The card \"c1\" already exists"),
                        user("c4"),
                        anyLine(),
                        user("d2"), containing("The definition \"d2\" already exists"),
                        user("d3"), containing("The definition \"d3\" already exists"),
                        user("d1"), containing("The definition \"d1\" already exists"),
                        user("d4"),

                        askCorrect("c1", "d1"),
                        askWrong("c2", userAns = "d1", rightAns = "d2", isDefFor = "c1"),
                        askWrong("c3", "d3 ddd3", "d3"),
                        askWrong("c4", "???", "d4")
                )
        )

        /** Asks with a correct answer. */
        private fun askCorrect(quest: String, userAns: String) = compositePhrase {
            listOf(containing("\"$quest\"", hint = "This line should ask the definition of `$quest`."),
                    user(userAns), containing("Correct answer"))
        }

        /** Asks with a wrong answer. */
        private fun askWrong(quest: String, userAns: String, rightAns: String, isDefFor: String? = null) = compositePhrase {
            val result = mutableListOf(
                    containing("\"$quest\"", hint = "This line should ask the definition of `$quest`."),
                    user(userAns))
            if (isDefFor == null) {
                result += containing("Wrong answer", "The correct one is \"$rightAns\"")
            } else {
                result += containing("Wrong answer", "The correct one is \"$rightAns\"",
                        "you've just written the definition of \"$isDefFor\"")
            }
            result
        }

        private fun inputNum(number: Int) = compositePhrase {
            listOf(anyLine(), user(number.toString()))
        }

        private fun inputCard(card: String, def: String) = compositePhrase {
            listOf(anyLine(), user(card), anyLine(), user(def))
        }


        override fun check(reply: String, clue: DialogClue): CheckResult {
            return clue.checkOutput(reply)
        }
    }
  learner_created: false
- name: src/flashcards/Main.java
  visible: true
  text: |
    package flashcards;

    public class Main {

        public static void main(String[] args) {
            FlashCardService flashCardService = new FlashCardService();
            flashCardService.init();
            flashCardService.fillFlashCards();
            flashCardService.requestDefinitions();
        }

    }
  learner_created: true
- name: src/flashcards/FlashCard.java
  visible: true
  text: |
    package flashcards;

    public class FlashCard {

        private static final String CARD = "Card:";
        private static final String DEFINITION = "Definition:";
        private final String card;
        private final String definition;

        public FlashCard(String card, String definition) {
            this.card = card;
            this.definition = definition;
        }

        public String getCard() {
            return card;
        }

        public String getDefinition() {
            return definition;
        }

        public boolean isCorrect(String answer) {
            return definition.equals(answer);
        }

        @Override
        public String toString() {
            return CARD + "\n" + card + "\n" + DEFINITION + "\n" + definition;
        }
    }
  learner_created: true
- name: src/flashcards/FlashCardService.java
  visible: true
  text: "package flashcards;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\
    import java.util.Scanner;\n\npublic class FlashCardService {\n\n    private Map<String,\
    \ String> cards = new LinkedHashMap<>();\n\n    public void init() {\n       \
    \ cards.clear();\n    }\n\n    public void fillFlashCards() {\n        final Scanner\
    \ scanner = new Scanner(System.in);\n        System.out.println(\"Input the number\
    \ of cards:\");\n        final int numberOfCards = Integer.parseInt(scanner.nextLine());\n\
    \n        for (int i = 0; i < numberOfCards; i++) {\n            String card =\
    \ \"\", definition = \"\";\n            int attempts = 0;\n            System.out.println(\"\
    The card #\" + (i + 1));\n\n            do {\n                if (attempts > 0)\
    \ {\n                    System.out.println(\"The card \\\"\" + card + \"\\\"\
    \ already exists. Try again:\");\n                }\n                card = scanner.nextLine();\n\
    \                attempts += 1;\n            } while (cards.containsKey(card));\n\
    \n            attempts = 0;\n            System.out.println(\"The definition of\
    \ the card #\" + (i + 1));\n            do {\n                if (attempts > 0)\
    \ {\n                    System.out.println(\"The definition \\\"\" + definition\
    \ + \"\\\" already exists. Try again:\");\n                }\n               \
    \ definition = scanner.nextLine();\n                attempts += 1;\n         \
    \   } while (cards.containsValue(definition));\n\n            cards.put(card,\
    \ definition);\n        }\n    }\n\n    public void requestDefinitions() {\n \
    \       final Scanner scanner = new Scanner(System.in);\n\n        for (Map.Entry<String,\
    \ String> e : cards.entrySet()) {\n            System.out.println(\"Print the\
    \ definition of \\\"\" + e.getKey() + \"\\\"\");\n            String inputDefinition\
    \ = scanner.nextLine();\n            if (e.getValue().equals(inputDefinition))\
    \ {\n                System.out.println(\"Correct answer\");\n               \
    \ continue;\n            }\n            \n            try {\n                String\
    \ solutionOf = getCardWithDefinition(inputDefinition);\n                System.out.println(\"\
    Wrong answer. The correct one is \\\"\" + e.getValue() + \"\\\",\" +\n       \
    \                 \" you've just written the definition of \\\"\" + solutionOf\n\
    \                        + \"\\\"\");\n            } catch (IllegalStateException\
    \ ex) {\n                System.out.println(\"Wrong answer. The correct one is\
    \ \\\"\" + e.getValue() + \"\\\"\");\n            }\n\n        }\n    }\n\n  \
    \  private String getCardWithDefinition(String definition) {\n        for (Map.Entry<String,\
    \ String> e : cards.entrySet()) {\n            if (e.getValue().equals(definition))\
    \ {\n                return e.getKey();\n            }\n        }\n\n        throw\
    \ new IllegalStateException(\"Unknown definition: \" + definition);\n    }\n}\n"
  learner_created: true
- name: todayLog.txt_re.txt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/44/stages/237/implement
status: Solved
feedback:
  message: Congratulations!
  time: Tue, 08 Dec 2020 09:23:17 UTC
record: 6
